/*! \file main.c
*
* DEPENDECIES: Kvaser CAN library: lcanlib lpthread
* 
*
* CMAKE: change to build folder and run the following CMAKE command to build a Eclipse project
*       ~\$ cd /build  
*       ~\$ cmake -G"Eclipse CDT4 - Unix Makefiles" -D CMAKE_BUILD_TYPE=Debug ../source 
*
*            Import the created project file into Eclipse
*
*            Import project using Menu File->Import
*            Select General->Existing projects into workspace:
*            Browse where your build tree is and select the root build tree directory. Keep "Copy projects into workspace" unchecked.
*            You get a fully functional eclipse project
*
*
*            I just spent some time struggling with this macro so I wanted to post an
* example. Maybe this can be used to expand on the documentation.
*
* First you need to collect all the headers on which you want to run moc:
*
* set (FOO_MOC_HEADERS foo_header.h)
*
* Next, you pass these headers to the qt4_wrap_cpp macro. You *also* pass
* a variable which will be populated with paths to the .cpp files
* generated by moc:
*
* qt4_wrap_cpp (FOO_MOC_OUTFILES ${FOO_MOC_HEADERS})
*
* Finally, you include the generated .cpp files generated by moc with your
* application/library:
*
* add_library (foo SHARED ${FOO_SOURCE_FILES} ${FOO_MOC_OUTFILES})
*
*
* The process is pretty simple, but deciphering that process was confusing
* to me so I hope this simple example is helpful.
*
*/

#include <canlib.h>
#include <stdio.h>
#include <iostream>
#include <signal.h>
#include <QSettings>
#include <QObject> 
#include <QTime>

#include "muscleDriverCANInterface.h"
#include "userInterface.h"
#include "log.h"

#include <QCoreApplication>
using namespace std;

//can appliation
KvaserCanInterface myCan;

int main (int argc, char *argv[])

{
  startLog();
  CAN_MESSAGE myCanMessage;
  STATUS_CODE myCanStatus;
  canHandle handle;
  canStatus status;
  int ret = -1;
  long id;
  unsigned char msg[8];
  unsigned int dlc;
  unsigned int flag;
  unsigned long time;
  int channelCount;
  int channel = 0;
  int bitrate = BAUD_1M;
  int j;
  unsigned int canData[4];

  QCoreApplication a(argc, argv);


  //start a CAN interface with a 1ms cycle time
  MuscleDriverCANInterface* canInterface  = new MuscleDriverCANInterface (5);

  QThread *canThread = new QThread;

  canInterface->moveToThread(canThread);
  canThread->start();


  QThread *thread = new QThread;
  UserInterface *myUserInterface = new UserInterface(canInterface);
  //obj is a pointer to a QObject that will trigger the work to start. It could just be this
  //  connect(obj, SIGNAL(startWork()), worker, SLOT(doWork()));
  myUserInterface->moveToThread(thread);



  //connect user interface to CAN application

  //starts the userInterface run function when can thread has started
  QObject::connect(thread, SIGNAL(started()), myUserInterface, SLOT(run()),Qt::DirectConnection );
thread->start();


  //cin>>startMotor;
  //if (st)
  //start CAN data processing
  //canInterface->start();


  cout<<" event loop"<<endl;
  //basic event-loop
  a.exec();

  cout<<"do we return?"<<endl;

  cout<<"waiting for 0 and return!"<<endl;
  cin>>j;

  cout<<endl<<"Quitting"<<endl;
}
